# Use a lightweight Debian base image for consistency
FROM debian:bookworm-slim

# Install dependencies required to build Erlang and Yaws
RUN apt-get update && apt-get install -y \
    build-essential \
    curl \
    libncurses5-dev \
    libssl-dev \
    autoconf \
    git \
    make \
    automake \
    libtool \
    gcc \
    autotools-dev \
    libpam0g-dev \
    sudo \
    libwxgtk3.2-dev \
    libgl1-mesa-dev \
    libglu1-mesa-dev \
    && apt-get clean && rm -rf /var/lib/apt/lists/*

# Download and build Erlang OTP 27.0.1 from source
RUN curl -L --http1.1 https://github.com/erlang/otp/releases/download/OTP-27.0.1/otp_src_27.0.1.tar.gz -o erlang.tar.gz && \
    tar -xzf erlang.tar.gz && \
    cd otp_src_27.0.1 && \
    ./configure && \
    make && make install && \
    cd .. && rm -rf erlang.tar.gz otp_src_27.0.1

# Clone and build the latest Yaws from source
RUN git clone https://github.com/erlyaws/yaws.git && \
    cd yaws && \
    autoreconf -fi && \
    ./configure && \
    make all && \
    make install && \
    cd .. && rm -rf yaws

# Create Yaws config directly
RUN mkdir -p /etc/yaws /var/log/yaws /var/www /app \
    && echo "logdir = /var/log/yaws\n\
    ebin_dir = /app\n\
    <server localhost>\n\
        port = 80\n\
        listen = 0.0.0.0\n\
        docroot = /var/www\n\
        appmods = </ws, ws_handler>\n\
    </server>" > /etc/yaws/yaws.conf

# Create WebSocket handler and compile it with fixed logic
RUN echo "-module(ws_handler).\n\
    -include_lib(\"yaws/include/yaws_api.hrl\").\n\
    -export([out/1, websocket_handler/2]).\n\
    out(Arg) ->\n\
        io:format(\"Handler loaded, processing request~n\"),\n\
        Headers = Arg#arg.headers,\n\
        io:format(\"Full headers: ~p~n\", [Headers]),\n\
        Upgrade = [Val || {http_header, _, 'Upgrade', _, Val} <- Headers#headers.other],\n\
        Connection = [Val || {http_header, _, 'Connection', _, Val} <- Headers#headers.other],\n\
        io:format(\"Upgrade header: ~p~n\", [Upgrade]),\n\
        io:format(\"Connection header: ~p~n\", [Connection]),\n\
        IsWebSocket = lists:member(\"websocket\", [string:to_lower(V) || V <- Upgrade]) andalso\n\
                      lists:any(fun(Conn) -> string:str(string:to_lower(Conn), \"upgrade\") > 0 end, Connection),\n\
        io:format(\"IsWebSocket: ~p~n\", [IsWebSocket]),\n\
        if IsWebSocket ->\n\
            io:format(\"Initiating WebSocket handshake~n\"),\n\
            {websocket, Arg, undefined};\n\
        true ->\n\
            io:format(\"Non-WebSocket request~n\"),\n\
            {content, \"text/plain\", \"Not a WebSocket request - use ws://\"}\n\
        end.\n\
    websocket_handler(Arg, _State) ->\n\
        io:format(\"WebSocket handler started~n\"),\n\
        websocket_loop(Arg).\n\
    websocket_loop(Arg) ->\n\
        receive\n\
            {binary, Data} ->\n\
                io:format(\"Received ~p bytes~n\", [byte_size(Data)]),\n\
                yaws_api:websocket_send(Arg#arg.clisock, {binary, Data}),\n\
                websocket_loop(Arg);\n\
            {close, Reason} ->\n\
                io:format(\"WebSocket closed: ~p~n\", [Reason]),\n\
                yaws_api:websocket_close(Arg#arg.clisock),\n\
                ok\n\
        after 3600000 ->\n\
            io:format(\"Timeout after 1 hour~n\"),\n\
            yaws_api:websocket_close(Arg#arg.clisock),\n\
            ok\n\
        end." > /app/ws_handler.erl \
    && erlc -o /app /app/ws_handler.erl

# Expose port
EXPOSE 80

# Start Yaws in daemon mode with corrected tracing
CMD ["/bin/sh", "-c", "yaws --daemon --conf /etc/yaws/yaws.conf --traceout && sleep infinity"]